#!/bin/bash

set -e

exec 3>&1
exec 1>&2

payload=$(mktemp)
cat > "$payload" <&0

manifest_url=$(jq -r '.source.manifest_url // "https://github.com/zephyrproject-rtos/zephyr"' < "$payload")
manifest_revision=$(jq -r '.source.manifest_revision // "main"' < "$payload")
manifest_path=$(jq -r '.source.manifest_path // "west.yml"' < "$payload")
current_commit=$(jq -r '.version.commit // ""' < "$payload")
current_manifest_sha256=$(jq -r '.version.manifest_sha256 // ""' < "$payload")
rm "$payload"

# Get latest commit from the manifest repo without a full clone
latest_commit=$(git ls-remote "$manifest_url" "refs/heads/$manifest_revision" | cut -f1)

if [ -z "$latest_commit" ]; then
    echo "Error: Could not fetch latest commit from $manifest_url branch $manifest_revision" >&2
    exit 1
fi

# Compute a frozen manifest fingerprint to detect changes in branch-tracked
# dependencies. west manifest --freeze resolves all project revisions (including
# branch names) to their current SHAs by querying each remote, without requiring
# a full west update.
tmpdir=$(mktemp -d)
trap "rm -rf $tmpdir" EXIT

echo "Resolving frozen manifest for $manifest_url @ $manifest_revision..."

# Shallow clone the manifest repo to avoid fetching full history
git clone --depth=1 --branch "$manifest_revision" "$manifest_url" "$tmpdir/manifest"

# Initialize a west workspace from the local clone
west init -m "$tmpdir/manifest" --mf "$manifest_path" "$tmpdir/workspace"

# Compute a manifest fingerprint without cloning any projects.
# west manifest --resolve merges all imports into a single YAML; for manifests
# with cross-repo project imports (e.g. a manifest that imports Zephyr's own
# west.yml), this requires those projects to be cloned first (west update).
# If resolve succeeds: hash the resolved YAML + the current remote HEADs of any
# branch-tracked projects (via git ls-remote), so the fingerprint changes
# whenever any branch-tracked dependency gets new commits.
# If resolve fails: the manifest likely pins all dependencies to fixed SHAs, so
# the manifest commit itself is a sufficient fingerprint.
if resolved=$(cd "$tmpdir/workspace" && west manifest --resolve 2>/dev/null); then
    branch_projects=$(python3 -c "
import sys, yaml, re
sha_re = re.compile(r'^[0-9a-fA-F]{40}$')
for p in yaml.safe_load(sys.stdin).get('manifest', {}).get('projects', []):
    rev = str(p.get('revision', 'HEAD'))
    if not sha_re.match(rev):
        print(p['url'] + '\t' + rev)
" <<< "$resolved")

    extra_shas=""
    while IFS=$'\t' read -r url rev; do
        [ -z "$url" ] && continue
        sha=$(git ls-remote "$url" "refs/heads/$rev" 2>/dev/null | cut -f1)
        extra_shas="${extra_shas} ${url}@${sha}"
    done <<< "$branch_projects"

    manifest_sha256=$(printf '%s\n%s\n' "$resolved" "$extra_shas" | sha256sum | cut -d' ' -f1)
else
    echo "west manifest --resolve unavailable (manifest has cross-repo imports requiring west update); using commit SHA as fingerprint." >&2
    manifest_sha256="$latest_commit"
fi

echo "Manifest commit:  $latest_commit"
echo "Manifest SHA256:  $manifest_sha256"

if [ "$current_commit" = "$latest_commit" ] && \
   [ -n "$current_manifest_sha256" ] && \
   [ "$current_manifest_sha256" != "null" ] && \
   [ "$current_manifest_sha256" = "$manifest_sha256" ]; then
    # Nothing changed
    versions=$(jq -n \
        --arg commit "$current_commit" \
        --arg sha256 "$current_manifest_sha256" \
        '[{commit: $commit, manifest_sha256: $sha256}]')
else
    # New version detected
    versions=$(jq -n \
        --arg commit "$latest_commit" \
        --arg sha256 "$manifest_sha256" \
        '[{commit: $commit, manifest_sha256: $sha256}]')
fi

echo "$versions" >&3
